## C++ 拾遗

## 为什么 main 函数要 return 0？
在大多数系统中，main 的返回值被用来指示状态。返回值 0 表明成功，非 0 的返回值的含义由系统定义，通常用来指出错误类型。

## do {...} while(0)
可能在一个方法中会出现 ABCD 四段代码块，其中 BC 两块有虚拟的包含关系，B 执行不了 C 也不执行，直接到 D。不用 do-while 也能解，就是不好看罢了。

## 带符号类型和无符号类型
带符号类型可以表示正数、负数或 0，无符号类型仅能表示大于 0 的值。

## 创建一个 C++ 对象何时用 new 何时不用？
一般来说，通过 `new` 关键词创建出的对象可以超出当前逻辑作用域，除非手动 delete 释放，否则不会自动释放。而通过类型 `Object obj;` 方式初始化的对象其生命周期终止与当前作用域。

## 顶层 const 和底层 const 之分
`const int i` 为顶层 const，i 的值无法被改变。

`int* const i` 为顶层 const，i 的值也无法改变，但可以修改指针所只指向的地址。

`const int* i` 为底层 const，i 的值可以改变，但无法修改指针所指向的地址。

综上，const 最近修饰的内容不可变。

## C++11 里的 const 和 constexpr
`const` 只作为“只读”。
`constexpr` 只作为“常量”。

## std::string size()
size 函数返回值的类型是 `size_type`，从 C++ Primer 书中看到的推测是一个无符号类型的值，因此绝对不可以与一个有符号且可能未负数的值进行比较，否则会出现明明比它大，却比它小的情况。

```c++
int a = -1;
std::string b = "123";
if (b.size() < a) {
    std::cout << "woc?"; // 会打印出 woc?
}
```

因此，当我们需要定义一个变量作为遍历或取 `std::string` 类型里的值时，可以把该变量类型定义为 `std::size_type` 类型，可以保证肯定不会出现小于 0 的场景。

## std::string 相加
当两个变量其中一个明确为 `std::string` 类型时，可以通过 + 运算符进行相加操作，若两个变量都通过字面量的方式进行相加，则是非法的，因为历史原因，也为了和 C 兼容，C++ 里的字符串字面量并不是标准库 `std::string` 类型。  

## std::vector
是模板而不是类型，其为 C++ 的“类模板”。

所有使用了迭代器的循环体，都不要向迭代器所属的容器增删元素。

## 在类的成员函数后加 const
当我们明确外部调用某些成员函数不可修改类内成员变量的内容时，可以通过在对应的函数声明后添加 const 关键字来告诉编译器，该方法不允许修改任何类内成员变量。

## class 和 struct 的区别
只有一个，默认的访问权限。如果我们明确了定义类的所有成员都是 public 的，则可以使用 struct。

## 如何声明一个使用默认构造函数初始化的对象？
```c++
Object obj; // 正确
Object obj(); // 错误，初始化了一个函数
```

## 类的静态成员变量
当一个变量只存在这个类内，但该类又会创建出多份，且都会使用同一个该变量，这种情况下可以使用静态成员变量。

