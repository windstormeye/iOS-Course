# HTTPS 通信原理剖析
## 基本概念
### 公钥密码体制（public-key cryptography）
公钥密码体制分为三个部分：**公钥**、**私钥**和**加密解密算法**。它的加密解密过程如下：
* 加密：通过加密算法和公钥对内容（或明文）进行加密，得到密文。加密过程需要用到公钥；
* 解密：通过解密算法和私钥对密文进行解密，得到明文。解密过程需要用到解密算法和私钥。注意，由公钥加密的内容，只能由私钥进行解密。

公钥密码体制的公钥和算法都是公开的，私钥是保密的。大家都使用公钥进行加密，但只有私钥的持有者才能进行解密，在实际的使用中，有需要的人会生成一对公钥和私钥，把公钥发布出去，私钥自己留着。

### 对称加密算法（symmetric key algorithms）
在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的，因此对称加密算法要保证安全性的话，密钥要做好保密，只能让使用的人知道，不能对外公开。与上文中国呢的公钥密码体制有所不同，公钥密码体制中加密是用公钥，解密是用私钥，而对称加密算法中，加密和解密都是使用同一个密钥，不区分公钥和私钥。

### 非对称加密算法（asymmetric key algorithms）
在非对称加密算法中，加密使用的密钥和解密使用的密钥是不相同的。前面所说的公钥密码体制就是一种非对称加密算法，它的公钥和私钥是不能相同的。

### RSA 简介
RSA 密码体制是一种公钥密码体制，公钥公开，私钥保密，它的加密解密算法是公开的，由公钥加密的内容可以并且只能由私钥进行解密，并且由私钥加密的内容可以并且只能由公钥进行解密。

### 签名和加密
加密，是指对某个内容加密，加密后的内容还可以通过解密进行还原。比如我们把电子邮件进行加密，在网络上传输给对方，对方通过解密后可以还原电子邮件的真实内容。

签名，是指在信息后面再加上一段内容，可以证明信息没有被修改过。一般是对信息做一个 hash 计算得到一个 hash 值（总之要不可逆），在把信息发出去后，把这个 hash 值作为一个签名和信息一块发出去。接收方在收到信息后，会重新计算信息的 hash 值，并和信息所附带的 hash 值（解密完）进行对比，如果一致，就说明信息的内容没有被修改过。当然，这么做还是有可能会让 hacker 在修改真实内容的同时修改 hash 值，为了防止这种情况，签名一般会加密后再和真实内容一起发送出去，保证该签名不被修改。（如何解密该签名，涉及到数字证书，后文讲解）

## 练练
### 一
假设服务器和客户端要在网络上通信，并且打算使用 RSA 来对通信进行加密以保证内容传输的安全，由于是使用 RSA 这种公钥密码体制，服务器需要对外发布公钥（算法不需要公布，RSA 算法大家都知道），自己留着私钥，客户端通过某些途径拿到了服务器发布的公钥，客户端并不知道私钥。

![20180930180914.png](https://i.loli.net/2018/09/30/5bb0a18be4a51.png)

如果有人 hack ，则会出现：

![20180930181454.png](https://i.loli.net/2018/09/30/5bb0a22a3aa27.png)

故客户端在接收到消息后，并不能肯定这个该消息就是由真实服务器发出的，可以被第三者冒充真实服务器发出该消息。那该如何确定该信息是由真实服务器发送过来的呢？我们知道，因为只有服务器才有私钥，所以能够确认只有对方才拥有私钥，那对方就是真实服务器，因此可为：

![20180930182012.png](https://i.loli.net/2018/09/30/5bb0a36c6d4a6.png)


* {!@#%} 为 RSA 加密后的内容；
* < a | b > 为用 a 密钥和 b 算法进行加密。
* {!@#%}<私钥 | RSA> 表示为用 私钥 对 “Server come” 进行加密后的结果。

为了向客户端证明自己是服务器，服务器先把一个字符串（Server come）用自己的私钥加密，把明文和加密后的密文一起发给客户端。客户端收到消息后，用自己的公钥解密密文，和明文进行比较，如果一致，说明信息的确是由服务器发过来的。因为由服务器用私钥加密后的内容由且只能由公钥进行解密，私钥只有服务器持有，所以如果解密出来的内容是能够对得上，那说明信息一定是从服务器发送过来的。


如果想 hack 服务器，

![WX20181008-153048@2x.png](https://i.loli.net/2018/10/08/5bbb080e06757.png)

在上图中的第四步{@@@@}<私钥 | RSA> ，这块是无法 hack 的，因为不知道私钥，无法用私钥加密，可以认定对方是个假货。

到这里，客户端可以确认服务器的身份了，可以放心的和服务器进行通信，但还有个问题，通信的内容在网络上还是无法保密，


![WX20181008-153912@2x.png](https://i.loli.net/2018/10/08/5bbb09b3a2a0c.png)


最后一步把用户的个人信息通过私钥加密发送出去了，因为公钥是所有人都知道的，除了这一个客户端，其它拥有公钥的客户端也能够对该条使用私钥进行加密的消息进行解密。一般会采用对称加密来解决这个问题。

![WX20181008-154655@2x.png](https://i.loli.net/2018/10/08/5bbb0b80ee78e.png)

在上图所示的通信过程中，客户端在确认了服务器身份后，自己选择一个对称加密算法和密钥，把选择的加密算法和密钥通过公钥进行加密发送给服务端。这个过程如果被 hack 了，但因为没有私钥也无法解密使用公钥加密后的内容。

RSA 加密算法在这个通信过程中所起到的作用主要有两个：
* 私钥只在服务器上，客户端可通过判断对方是有拥有私钥来保证是否为“真”服务器；
* 客户端通过 RSA 的掩护，安全的和服务器商量好一个对称加密算法和密钥来保证后续通信过程内容的安全。

这引发出了一个新的问题，服务器要对外发布公钥，服务器如何把公钥发送给客户端呢？可能会想到：
* 把公钥放到网络上的某个地址，都去这拿；
* 每次通信开始都下发公钥。

第一个方法的问题出在下载地址会被伪造，第二个方法的容易被中间人伪造，因为我们都可以生成公钥和私钥，无法确认公钥到底是谁的，如果能够确认公钥到底是谁的即可解决。

为了解决这个问题，数字证书出现了。一个证书包含了以下内容：
* 证书的发布机构
* 证书的有效期
* 公钥
* 证书的所有者
* 签名所使用的算法
* 指纹及指纹算法

这样，通信流程就变成了：

![WX20181008-155723@2x.png](https://i.loli.net/2018/10/08/5bbb0df548216.png)

上图中的第二次通信，服务器把自己的证书发给了客户端而不是公钥。客户端根据证书校验来确认证书是否为服务器的，后续操作都是一致的。

为了保证安全，在证书的发布机构发布证书时，证书的指纹和指纹算法都会加密后再和证书放到一起发布，以防有人修改指纹后伪造相应的数字证书。那证书的指纹和指纹算法用什么加密呢？答案是用那个证书发布机构的私钥进行加密的，也就是说，证书发布机构除了给别人发布证书外，自己本身也有自己的证书（一般由自己生成）。在 OS 安装好时，这些证书发布机构的数字证书就已经被安装在其中了，操作系统厂商会根据一些权威安全机构的评估选取一些信誉很好并且通过一定安全认证的证书发布机构，把这些证书发布机构的证书默认安装在 OS 中，且设置为 OS 信任的数字证书。这些证书发布机构自己持有与自己的数字证书对应的私钥，会用这个私钥加密所有发布证书的指纹作为数字签名。


-----


## 初涉 HTTPS （超文本传输安全协议，也被称为 HTTP over TLS，HTTP over SSL 或 HTTP Secure ）

首先明确一个概念，HTTPS 并没有推翻之前的 HTTP 协议，而是一个安全的 HTTP 。

> HTTPS 开发的主要目的，是提供对网络服务器的认证，保证交换信息的机密性和完整性。

末尾的 S 指的是 SSL ( Secure Sockets Layer 安全套接层)， /TLS （传输层安全性协议，英语：Transport Layer Security，缩写为 TLS ）。该层协议位于 HTTP 协议和 TCP/IP 协议的中间

所谓的信息传输安全指的是:

1. 客户端和服务器传输信息只有双方才能看懂。
2. 为了防止第三方就算看不懂数据也会瞎改的情况，客户端和服务器要有能力去验证数据是否被修改过；
3. 客户端必须要防止避免中间人攻击，除了真正要建立连接的服务器外，任何第三方都无法冒充真实服务器。

对于信息的加密，可以通过对称和非对称加密。简单来说，对称加密是客户端和服务器双方都约定俗成了一套加密规则，当然这套规则可以是客户端和服务器开始建立连接之前就已经规定好，也可以在已经建立连接时，向服务器先请求加密规则。

此时的 HTTPS 握手流程多了两步：

> 客户端：服务器，我需要发起一个 HTTPS 请求

> 服务器：客户端，你的秘钥是 xxxx

而非对称加密也可以简单得认为是客户端有自己的一套加解密规则（公钥），服务器有自己的一套加解密规则（私钥），经过服务器的加解密规则（私钥）加密后的数据只有客户端的加解密规则（公钥）才能解析，经过客户端加解密规则（公钥）只有服务器的加解密规则（私钥）才能解析。

由此可见，用对称加密进行数据传输肯定比非对称加密快得多。当然，私钥是服务器自己留着的，不对外公开的，而公钥是可对外公开获取的。
那么现在又引入了一个问题，对称加密的秘钥怎么传输？服务器直接明文返回对称加密的秘钥肯定是不科学的，而且我们还不能直接用一个新的对称加密算法去加密原来的对称秘钥，因为这又涉及了新的对称加密秘钥如何传输的问题，这是个悖论。

OK，为了解决这个问题，就用上了之前我们说的非对称加密方式，从上文我们所讲的非对称加密特点，服务器用私钥加密的数据实际上并不是真正意义上的加密，因为只要有私钥与之对应的公钥即可解密，更何况公钥谁都可以有，谁都可是是客户端，所有服务器的密码能被所有人进行解析，但私钥只存在服务器上，这就说明了：

1. 服务器下发的内容不可被伪造，因为私钥唯一，如果第三方 **强行二次加密** 则客户端的公钥无法解密；
2. 任何用公钥加密的内容都是 **绝对安全** 的，因为私钥唯一，只有拥有私钥的真正服务器才可进行解密。

故解决了我们之前的问题，秘钥并不是服务器生成，而是客户端自行用公钥生成且主动告诉服务器的，此时 HTTPS 的握手流程就变成了：

> 客户端：服务器，我要发起一个 HTTPS 请求，这是我用你下发的公钥生成的秘钥。

> 服务器：我知道了，以后咱们用这个秘钥进行验证。

OK，现在进入下一个问题，那这个公钥如何下发给客户端？啊哈，其实之前用“下发”这个词是为了好理解，实际上应该是每个使用了 HTTPS 协议的服务器都应该去一个专门的证书机构注册一个证书，这个证书中保存了权威证书机构私钥加密的公钥，客户端就用这个权威证书机构的公钥作为其的 HTTPS 公钥即可。

因此，HTTPS 握手流程就变为了：

> 客户端：服务器！我要发起一个 HTTPS 请求，给我公钥！

> 服务器：好的，我给你个证书，自己从里边拿。

> 客户端：（解密成功后）这是我解密完后的秘钥

> 服务器：我知道了，以后咱们用这个秘钥（公钥）进行验证。


实际上 `HTTPS` 并不是重新构建了一套传输协议，而是与上文中所说的一样，只是在原有传输协议的应用层和传输层之间多添加了一个安全层（会话层），如下图所示：

<img src="https://i.loli.net/2018/06/01/5b11446f898ae.png" width = "70%" height = "70%" align=center />

emmm，其实我弄到这也懵逼了，这所谓的权威证书机构公钥又如何传输？查了相关资料后发现，其实就是内置在了 OS 或者浏览器中，但是这有个问题，我们不可能穷举所有权威证书机构服务器，太多了根本存不完，而且 OS 会对其产生怀疑，凭啥你说这证书可靠就是可靠？

故，我们可以认为全世界上的权威认证机构只有一个（实践上并不），其它的想搞证书这门生意的公司得去这个唯一权威认证机构去取得认证，所以 OS 或浏览器只需要维护这一个权威认证机构的公钥即可。每次客户端只需要获取这个公钥即可。

到现在算是把我的 HTTPS 的疑惑解决得差不多了，但是还有个问题，现在证书也有个唯一的机构去做认证了，但是我们却没法知道这个证书是否真的可靠，就好像我们都知道人民币都是中国人民银行唯一认证和发行的，但是没人保证每张人民币都是真币，紫外线验证是一种人民币有效性验证的手段，那对于证书来说，如何做有效性验证呢？

又查了一波资料，每份证书会有各自对应的 hash 值，在传输证书的时候也会同时传输对应证书的 hash 值。如果此时有中间人进行攻击，因为公钥不唯一，谁都可以进行解密，但是其伪造的数据经过中间人的私钥加密后，无法正确加密，再次返回给客户端的数据经过客户端公钥解密后是乱码，如果凑巧对上了，但是也无法通过 hash 校验（至于如何校验，我还没查到）

从以上观点我们可以看出，貌似 HTTPS 坚不可破啊，它真的是无敌了么？其实从某种意义上来看，它还真的就无敌了，但也不是万无一失，因为如果我们第一次请求的就不是真的服务器，而是一个攻击者，这就完全有机会进行所谓的中间人攻击。正常的流程是在第一次握手时，服务器会下发给客户端证明自己身份的证书，客户端再用预设在设备上的公钥来解密。

但是如果我们不小心在自己的设备上安装了非权威认证机构的根证书，比如 Charles 的私有根证书，那么我们的设备上就多了一个预设的公钥，那通过Charles的私钥加密的证书就能够被正常解析出来，Charles对于我们的设备来说相当于是设备的服务器，对真的服务器来说，Charles是客户端，所以相当于Charles既拿到了私钥又拿到了公钥，能够解析并修改数据也就不在话下了，不过也不要觉得 Charles 是啥恐怖的东西，我们之所以使用 Charles 进行抓包，是因为我们信任它，你都信任了还有啥欺骗不欺骗的，中间人攻击也就不存在了，但如果你的 Charles 是个盗版的，很有可能下发这个盗版 Charles 的开发者就已经给你开了个后门。支持正版，从我做起。


### 更进一步

#### TLS协议做了什么？

正如上文所说， `HTTPS` 只是比 `HTTP` 多了一个安全层，那么这个传输层安全协议到底是怎么一回事呢？在此做了一张图分享如下， `TLS` 运行在一个可靠的 `TCP` 协议上。

1. 客户端和服务器还是跟原来一样进行 `TCP` 三次握手，握手完后，客户端和服务器建立起了连接;
2. 客户端像服务器发送一系列说明，比如客户端使用的 `TLS` 协议版本，支持的加密算法等等;
3. 服务器拿到了客户端发送而来的说明，从中获取到客户端支持的 `TLS` 协议版本和支持的加密算法列表，从列表中选择一个合适的加密算法，将选择的加密算法和证书一同发送给客户端；
4. 客户端拿到确定的 `TLS` 版本和加密算法，并检测服务端的证书，通过后使用公钥进行加密某个数据（例如：“完成”）；
5. 服务器使用私钥解密客户端公钥加密过的消息，并验证 `MAC` （ Message Authentication Code ，消息认证码）把解密出的消息（例如：“完成”）使用私钥加密发送给客户端；
6. 客户端使用公钥解密消息，并验证 `MAC` ，通过后加密通道建立，以后在该加密通道进行的数据传输都采用对称秘钥对数据加密。

由此可见，是先经过了非对称加密，最后再进行对称加密，也即——对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，服务器使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行数据传输。流程如下图所示：

<img src="https://i.loli.net/2018/06/01/5b114aeb7e009.png" width = "70%" height = "70%" align=center />

## iOS 中的 HTTPS
`AFSecurityPolicy` 这个类为 AFN 设置 SSL 钢钉的类，有 3 种验证方式：
1. `AFSSLPinningModeNone`：这个模式表示不做 SSL pining ，跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。如果证书是信任机构签发的就会通过，如果是自己服务器生成的证书，就不会通过。（注意：该模式是不安全的，HTTPS API 能正常访问，但没有校验证书，失去了 HTTPS 的意义）
2. `AFSSLPinningModePublicKey`：代表客户端回将服务器端返回的证书与本地保存的证书中的 `PublickKey` 部分进行校验，校验通过后才继续进行。
3. `AFSSLPinningModeCertificate`：代表客户端会将服务器端返回的证书和本地保存的证书中的所有内容进行匹配，全部进行校验，如果正确，才继续进行通信。

2 和 3 都需要把证书内置在 app bundle 中。

## 超文本链接
原来超文本链接可以用指针去理解，指针是指向了一块内存地址，那超文本链接实际上就是指向了服务器上的一个资源位置哇！！！

## `HTTP` 协议特点
优点：解放了服务器，每一次请求“点到为止”，不会造成不必要的连接占用。

缺点：每次请求会传输大量的重复内容信息。

* 支持客户端/服务器模式
* 简单快捷
* 灵活
* 无连接
* 无状态

**无连接**：服务端处理完客户端一次请求，等到客户端作出回应之后（确定收到）便断开连接。这种方式节省传输时间，但随着业务量的庞大，如果还采用原来的方式，会在建立和断开连接上话费大部分时间。`HTTP` 借助底层的 `TCP` 虚拟连接（并不是真实的电路连接），`HTTP` 协议无需连接，比如 A 和 B 打电话，A 和 B 两者并没有进行“连接”，而是借助了电话简化了连接从而进行交换信息。

**无状态**：服务端对客户端每次发送的请求都认为是一个新的请求，上一次会话和下一次会话之间没有联系。

**HTTP 0.9**：短连接。每个 `HTTP` 请求都要经历一次 `DNS` 解析，三次握手，传输和四次挥手。

**HTTP 1.0**：持久连接（长连接）被提出来。在此之前，每次连接只处理一个请求，且每个连接的获取都需要创建一个独立的 `TCP` 连接，因为 `HTTP` 是基于 `TCP/IP` 协议的，创建一个 `TCP` 连接需要经过三个步骤，有一定的开销，如果每次通讯如果每次都需要重新建立连接，对性能有影响，所以最好是需要维护一个长连接。当一个 `TCP` 连接对服务器做了多次请求：客户端可以在 `request header` 中携带 `Connection: Keep-Alive` 字段向服务器请求持久连接，若服务器允许就会在 `response header` 中加上相同字段。

双方都确认后，客户端便可继续使用同一个 `TCP` 连接发送接下来若干请求。`Keep-Alive` 默认是 `[timeput=5, max=100]` ，即每一个 `TCP` 连接可以服务最多 5 秒内的 100 次请求。当服务端主动切断一个长连接时（或不支持），则会在 `response header` 中携带 `Connection:Close` ，要求客户端停止使用这一连接。

长连接机制仍然是串行的，如果某个请求出现网络阻塞等问题，会导致同一条连接上的后续请求被阻塞。

**HTTP 1.1**：提出 `piplining` （管线化）机制，且默认支持长连接，就算客户端 `request header` 中未携带 `Connection:Keep-Alive` ，传输也会默认支持。客户端发起一次请求时不必等待响应便直接发起第二个请求；服务端根据请求顺序一次放回结果。该机制基于长连接完成，且只有 `GET` 和 `HEAD` 请求可进行 `piplining` ， `POST` 请求会有所限制。第一次建立连接时服务器不一定支持 `HTTP 1.1` 协议。

该机制可将 `HTTP` 请求大批量提交，将多个请求同时塞入一个 `TCP` 分组中，达到只提交一个分组即可同时发出多个要求，大幅缩短页面加载时间（特别是在传输延迟较高的情况下），减少网络上多余的分组并降低线路负载。

支持只发送 `header` 信息（ `HEAD` 方法），如果服务器认为客户端有权限请求，则返回 100 ，否则返回 401 。客户端如果接受到 100 ，才开始把请求 `body` 发送到服务器，并且还支持传送内容的一部分，当客户端已经有了一部分资源后，只需要跟服务器请求另外部分资源即可（断点续传的基础）

**HTTP 2.0**：多路复用技术出现。能够让多个 `request` 和 `response` 杂糅在一起，通过 `streamID` 区别。


## TCP
* `TCP` 提供一种面向连接的、可靠的字节流服务；
* 在一个 `TCP` 连接中，仅有双方进行彼此通信。广播和多播不能用于 `TCP`；
* `TCP` 使用校验和、确认和重传机制来保证可靠传输；
* `TCP` 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复；
* `TCP` 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制。（🧐 没搞懂）

`TCP` 连接有一个“预热”过程，先检查数据是否传输成功，一旦传输成功过，则慢慢加大传输速度。如果对应瞬时并发的连接，服务器的响应就会变慢。

### 三次握手
三次握手（Three-way Handshake），是指建立一个 TCP 连接时，需要客户端和服务器总共发送 **3** 个包。三次握手的目的是为了连接服务器制定端口，建立 TCP 连接，并同步连接双方的 **序列号** 和 **确认号** ，交换 TCP 窗口大小信息。

* 第一次握手：客户端发送一个位码 SYN = 1 ，以及随机产生的 seq number = x 。发送完毕后，客户端进入 `SYN_SEND` 状态。服务器由 syn = 1 得知客户端需要建立连接。

* 第二次握手：服务器要确认连接信息，向客户端发送 ack number = y ( x + 1 )， syn = 1 ， ack = 1 ，并随机产生 seq = y。发送完毕后，服务器进入 `SYN_RCVD` 状态。

* 第三次握手：客户端收到数据包后，验证 y == x + 1 ，位码 ack == 1 。验证通过后，客户端发送 ack number = z（y + 1） ， ack = 1 ，发送完毕后，客户端进入 `ESTABLISHED` 状态，服务器收到后验证 z == y + 1 ，ack == 1 ，验证通过后，建立连接，服务器进入 `ESTABLISHED` 状态，TCP 三次握手建立连接结束。

## ARP 
ARP 协议 `OSI` 五层模型中的数据链路层，是把 IP 地址转化成 MAC 地址的一个 `TCP/IP` 协议。
